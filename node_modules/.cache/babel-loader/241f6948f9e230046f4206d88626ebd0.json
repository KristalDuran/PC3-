{"ast":null,"code":"var __rest = this && this.__rest || function (s, e) {\n  var t = {};\n\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0) t[p[i]] = s[p[i]];\n  return t;\n};\n\nimport { markerRendering, convertTileLatLongToPoint, MapLocation } from '../index';\nimport { markerClick, markerMouseMove, markerClusterClick, markerClusterMouseMove } from '../index';\nimport { isNullOrUndefined, createElement } from '@syncfusion/ej2-base';\nimport { getTranslate, convertGeoToPoint, clusterTemplate, marker, markerTemplate, getZoomTranslate } from '../utils/helper';\nimport { getElementByID, mergeSeparateCluster, clusterSeparate, removeElement, getElement, markerColorChoose, markerShapeChoose, calculateZoomLevel, compareZoomFactor, getValueFromObject } from '../utils/helper';\n/**\n * Marker class\n */\n\nvar Marker =\n/** @class */\nfunction () {\n  function Marker(maps) {\n    this.maps = maps;\n    this.trackElements = [];\n    this.sameMarkerData = [];\n  }\n  /* tslint:disable:no-string-literal */\n\n\n  Marker.prototype.markerRender = function (layerElement, layerIndex, factor, type) {\n    var _this = this;\n\n    var templateFn;\n    var markerCount = 0;\n    var nullCount = 0;\n    var markerTemplateCount = 0;\n    this.maps.translateType = 'marker';\n    var currentLayer = this.maps.layersCollection[layerIndex];\n    this.markerSVGObject = this.maps.renderer.createGroup({\n      id: this.maps.element.id + '_Markers_Group',\n      class: 'GroupElement',\n      style: 'pointer-events: auto;'\n    });\n    var markerTemplateEle = createElement('div', {\n      id: this.maps.element.id + '_LayerIndex_' + layerIndex + '_Markers_Template_Group',\n      className: this.maps.element.id + '_template',\n      styles: 'overflow: hidden; position: absolute;pointer-events: none;' + 'top:' + this.maps.mapAreaRect.y + 'px;' + 'left:' + this.maps.mapAreaRect.x + 'px;' + 'height:' + this.maps.mapAreaRect.height + 'px;' + 'width:' + this.maps.mapAreaRect.width + 'px;'\n    }); //tslint:disable\n\n    currentLayer.markerSettings.map(function (markerSettings, markerIndex) {\n      var markerData = markerSettings.dataSource;\n      Array.prototype.forEach.call(markerData, function (data, dataIndex) {\n        _this.maps.markerNullCount = markerIndex > 0 && dataIndex === 0 ? 0 : _this.maps.markerNullCount;\n        var eventArgs = {\n          cancel: false,\n          name: markerRendering,\n          fill: markerSettings.fill,\n          height: markerSettings.height,\n          width: markerSettings.width,\n          imageUrl: markerSettings.imageUrl,\n          shape: markerSettings.shape,\n          template: markerSettings.template,\n          data: data,\n          maps: _this.maps,\n          marker: markerSettings,\n          border: markerSettings.border,\n          colorValuePath: markerSettings.colorValuePath,\n          shapeValuePath: markerSettings.shapeValuePath,\n          imageUrlValuePath: markerSettings.imageUrlValuePath\n        };\n        eventArgs = markerColorChoose(eventArgs, data);\n        eventArgs = markerShapeChoose(eventArgs, data);\n\n        if (_this.maps.isBlazor) {\n          var maps = eventArgs.maps,\n              marker_1 = eventArgs.marker,\n              blazorEventArgs = __rest(eventArgs, [\"maps\", \"marker\"]);\n\n          eventArgs = blazorEventArgs;\n          markerSettings.longitudeValuePath = !isNullOrUndefined(markerSettings.longitudeValuePath) ? markerSettings.longitudeValuePath : !isNullOrUndefined(data['Longitude']) ? 'Longitude' : !isNullOrUndefined(data['longitude']) ? 'longitude' : null;\n          markerSettings.latitudeValuePath = !isNullOrUndefined(markerSettings.latitudeValuePath) ? markerSettings.latitudeValuePath : !isNullOrUndefined(data['Latitude']) ? 'Latitude' : !isNullOrUndefined(data['latitude']) ? 'latitude' : null;\n        }\n\n        _this.maps.trigger('markerRendering', eventArgs, function (MarkerArgs) {\n          if (markerSettings.colorValuePath !== eventArgs.colorValuePath) {\n            eventArgs = markerColorChoose(eventArgs, data);\n          }\n\n          if (markerSettings.shapeValuePath !== eventArgs.shapeValuePath) {\n            eventArgs = markerShapeChoose(eventArgs, data);\n          }\n\n          var lng = !isNullOrUndefined(markerSettings.longitudeValuePath) ? Number(getValueFromObject(data, markerSettings.longitudeValuePath)) : !isNullOrUndefined(data['longitude']) ? parseFloat(data['longitude']) : !isNullOrUndefined(data['Longitude']) ? parseFloat(data['Longitude']) : 0;\n          var lat = !isNullOrUndefined(markerSettings.latitudeValuePath) ? Number(getValueFromObject(data, markerSettings.latitudeValuePath)) : !isNullOrUndefined(data['latitude']) ? parseFloat(data['latitude']) : !isNullOrUndefined(data['Latitude']) ? parseFloat(data['Latitude']) : 0;\n\n          if (_this.maps.isBlazor) {\n            var data1 = {};\n            var text = [];\n            var j = 0;\n\n            for (var i = 0; i < Object.keys(data).length; i++) {\n              if (Object.keys(data)[i].toLowerCase() !== 'latitude' && Object.keys(data)[i].toLowerCase() !== 'longitude' && Object.keys(data)[i].toLowerCase() !== 'name' && Object.keys(data)[i].toLowerCase() !== 'blazortemplateid' && Object.keys(data)[i].toLowerCase() !== 'text') {\n                text[j] = data[Object.keys(data)[i].toLowerCase()];\n                data1['text'] = text;\n                j++;\n              }\n            }\n\n            data['text'] = data1['text'];\n          }\n\n          var offset = markerSettings.offset;\n\n          if (!eventArgs.cancel && markerSettings.visible && !isNullOrUndefined(lng) && !isNullOrUndefined(lat)) {\n            var markerID = _this.maps.element.id + '_LayerIndex_' + layerIndex + '_MarkerIndex_' + markerIndex + '_dataIndex_' + dataIndex;\n            var location_1 = _this.maps.isTileMap ? convertTileLatLongToPoint(new MapLocation(lng, lat), factor, _this.maps.tileTranslatePoint, true) : convertGeoToPoint(lat, lng, factor, currentLayer, _this.maps);\n            var animate = currentLayer.animationDuration !== 0 || isNullOrUndefined(_this.maps.zoomModule);\n            var translate = _this.maps.isTileMap ? currentLayer.type === \"SubLayer\" && isNullOrUndefined(_this.maps.zoomModule) ? location_1 = convertTileLatLongToPoint(new MapLocation(lng, lat), _this.maps.tileZoomLevel, _this.maps.tileTranslatePoint, true) : new Object() : !isNullOrUndefined(_this.maps.zoomModule) && _this.maps.zoomSettings.zoomFactor > 1 ? getZoomTranslate(_this.maps, currentLayer, animate) : getTranslate(_this.maps, currentLayer, animate);\n            var scale = type === 'AddMarker' ? _this.maps.scale : translate['scale'];\n            var transPoint = type === 'AddMarker' ? _this.maps.translatePoint : translate['location'];\n\n            if (eventArgs.template && !isNaN(location_1.x) && !isNaN(location_1.y)) {\n              markerTemplateCount++;\n              markerTemplate(eventArgs, templateFn, markerID, data, markerIndex, markerTemplateEle, location_1, scale, offset, _this.maps);\n            } else if (!eventArgs.template && !isNaN(location_1.x) && !isNaN(location_1.y)) {\n              markerCount++;\n              marker(eventArgs, markerSettings, markerData, dataIndex, location_1, transPoint, markerID, offset, scale, _this.maps, _this.markerSVGObject);\n            }\n          }\n\n          nullCount += !isNaN(lat) && !isNaN(lng) ? 0 : 1;\n          markerTemplateCount += eventArgs.cancel ? 1 : 0;\n          markerCount += eventArgs.cancel ? 1 : 0;\n          _this.maps.markerNullCount = isNullOrUndefined(lng) || isNullOrUndefined(lat) ? _this.maps.markerNullCount + 1 : _this.maps.markerNullCount;\n          var markerDataLength = markerData.length - _this.maps.markerNullCount;\n\n          if (_this.markerSVGObject.childElementCount === markerDataLength - markerTemplateCount - nullCount && type !== 'Template') {\n            layerElement.appendChild(_this.markerSVGObject);\n\n            if (currentLayer.markerClusterSettings.allowClustering) {\n              _this.maps.svgObject.appendChild(_this.markerSVGObject);\n\n              _this.maps.element.appendChild(_this.maps.svgObject);\n\n              clusterTemplate(currentLayer, _this.markerSVGObject, _this.maps, layerIndex, _this.markerSVGObject, layerElement, true, false);\n            }\n          }\n\n          if (markerTemplateEle.childElementCount === markerData.length - markerCount - nullCount && getElementByID(_this.maps.element.id + '_Secondary_Element')) {\n            getElementByID(_this.maps.element.id + '_Secondary_Element').appendChild(markerTemplateEle);\n\n            if (currentLayer.markerClusterSettings.allowClustering) {\n              clusterTemplate(currentLayer, markerTemplateEle, _this.maps, layerIndex, _this.markerSVGObject, layerElement, false, false);\n            }\n          }\n        });\n      });\n    });\n  };\n  /**\n   * To find zoom level for individual layers like India, USA.\n   */\n\n\n  Marker.prototype.calculateIndividualLayerMarkerZoomLevel = function (mapWidth, mapHeight, maxZoomFact) {\n    var latZoom;\n    var lngZoom;\n    var result;\n    var scaleFactor;\n    var height = Math.abs(this.maps.baseMapBounds.latitude.max - this.maps.baseMapBounds.latitude.min);\n    var width = Math.abs(this.maps.baseMapBounds.longitude.max - this.maps.baseMapBounds.longitude.min);\n    latZoom = Math.floor(Math.log(mapHeight / height));\n    latZoom = latZoom > maxZoomFact ? maxZoomFact : latZoom;\n    lngZoom = Math.floor(Math.log(mapWidth / width));\n    lngZoom = lngZoom > maxZoomFact ? maxZoomFact : lngZoom;\n    result = Math.min(latZoom, lngZoom);\n    scaleFactor = Math.min(result, maxZoomFact - 1);\n\n    if (!this.maps.isTileMap) {\n      compareZoomFactor(scaleFactor, this.maps);\n    }\n\n    return scaleFactor;\n  };\n  /**\n   * To calculate center position and factor value dynamically\n   */\n\n\n  Marker.prototype.calculateZoomCenterPositionAndFactor = function (layersCollection) {\n    if (this.maps.zoomSettings.shouldZoomInitially && this.maps.markerModule) {\n      var minLong_1;\n      var maxLat_1;\n      var minLat_1;\n      var maxLong_1;\n      var latZoom = void 0;\n      var lngZoom = void 0;\n      var result = void 0;\n      var zoomLevel = void 0;\n      var centerLat = void 0;\n      var centerLong = void 0;\n      var maxZoomFact = 10;\n      var mapWidth = this.maps.mapAreaRect.width;\n      var mapHeight = this.maps.mapAreaRect.height;\n      var scaleFactor = void 0;\n      this.maps.markerZoomedState = this.maps.markerZoomedState ? this.maps.markerZoomedState : isNullOrUndefined(this.maps.markerZoomFactor) ? !this.maps.markerZoomedState : this.maps.markerZoomFactor > 1 ? this.maps.markerZoomedState : !this.maps.markerZoomedState;\n      this.maps.defaultState = this.maps.markerZoomedState ? !this.maps.markerZoomedState : this.maps.defaultState;\n      Array.prototype.forEach.call(layersCollection, function (currentLayer, layerIndex) {\n        var isMarker = currentLayer.markerSettings.length !== 0;\n\n        if (isMarker) {\n          Array.prototype.forEach.call(currentLayer.markerSettings, function (markerSetting, markerIndex) {\n            var markerData = markerSetting.dataSource;\n            Array.prototype.forEach.call(markerData, function (data, dataIndex) {\n              var latitude = !isNullOrUndefined(data['latitude']) ? parseFloat(data['latitude']) : !isNullOrUndefined(data['Latitude']) ? parseFloat(data['Latitude']) : null;\n              var longitude = !isNullOrUndefined(data['longitude']) ? parseFloat(data['longitude']) : !isNullOrUndefined(data['Longitude']) ? parseFloat(data['Longitude']) : null;\n              minLong_1 = isNullOrUndefined(minLong_1) && dataIndex === 0 ? longitude : minLong_1;\n              maxLat_1 = isNullOrUndefined(maxLat_1) && dataIndex === 0 ? latitude : maxLat_1;\n              minLat_1 = isNullOrUndefined(minLat_1) && dataIndex === 0 ? latitude : minLat_1;\n              maxLong_1 = isNullOrUndefined(maxLong_1) && dataIndex === 0 ? longitude : maxLong_1;\n\n              if (minLong_1 > longitude) {\n                minLong_1 = longitude;\n              }\n\n              if (minLat_1 > latitude) {\n                minLat_1 = latitude;\n              }\n\n              if (maxLong_1 < longitude) {\n                maxLong_1 = longitude;\n              }\n\n              if (maxLat_1 < latitude) {\n                maxLat_1 = latitude;\n              }\n            });\n          });\n        }\n      });\n\n      if (!isNullOrUndefined(minLat_1) && !isNullOrUndefined(minLong_1) && !isNullOrUndefined(maxLong_1) && !isNullOrUndefined(maxLat_1)) {\n        // To find the center position\n        centerLat = (minLat_1 + maxLat_1) / 2;\n        centerLong = (minLong_1 + maxLong_1) / 2;\n        this.maps.markerCenterLatitude = centerLat;\n        this.maps.markerCenterLongitude = centerLong;\n\n        if (isNullOrUndefined(this.maps.markerZoomCenterPoint) || this.maps.markerZoomedState) {\n          this.maps.markerZoomCenterPoint = {\n            latitude: centerLat,\n            longitude: centerLong\n          };\n        }\n\n        var markerFactor = void 0;\n\n        if (this.maps.isTileMap || this.maps.baseMapRectBounds['min']['x'] === 0) {\n          zoomLevel = calculateZoomLevel(minLat_1, maxLat_1, minLong_1, maxLong_1, mapWidth, mapHeight, this.maps);\n\n          if (this.maps.isTileMap) {\n            markerFactor = isNullOrUndefined(this.maps.markerZoomFactor) ? zoomLevel : isNullOrUndefined(this.maps.mapScaleValue) ? zoomLevel : this.maps.mapScaleValue > 1 && this.maps.markerZoomFactor !== 1 ? this.maps.mapScaleValue : zoomLevel;\n          } else {\n            markerFactor = isNullOrUndefined(this.maps.mapScaleValue) ? zoomLevel : Math.floor(this.maps.scale) !== 1 && this.maps.mapScaleValue !== zoomLevel && isNullOrUndefined(this.maps.shouldZoomCurrentFactor) ? this.maps.mapScaleValue : zoomLevel;\n\n            if (markerFactor === this.maps.mapScaleValue && (this.maps.markerZoomFactor === 1 || this.maps.mapScaleValue === 1) && !this.maps.enablePersistence) {\n              markerFactor = zoomLevel;\n            }\n          }\n        } else {\n          zoomLevel = this.calculateIndividualLayerMarkerZoomLevel(mapWidth, mapHeight, maxZoomFact);\n          markerFactor = isNullOrUndefined(this.maps.mapScaleValue) ? zoomLevel : this.maps.mapScaleValue !== zoomLevel ? this.maps.mapScaleValue : zoomLevel;\n        }\n\n        this.maps.markerZoomFactor = markerFactor;\n      }\n    } else {\n      this.maps.markerZoomedState = false;\n\n      if (this.maps.markerZoomFactor > 1) {\n        this.maps.markerCenterLatitude = null;\n        this.maps.markerCenterLongitude = null;\n        this.maps.markerZoomFactor = 1;\n\n        if (!this.maps.enablePersistence) {\n          this.maps.mapScaleValue = 1;\n        }\n      }\n\n      if (this.maps.isTileMap && !this.maps.enablePersistence && this.maps.mapScaleValue <= 1) {\n        this.maps.tileZoomLevel = this.maps.mapScaleValue === 0 ? 1 : this.maps.mapScaleValue;\n\n        if (this.maps.mapScaleValue === 1 && this.maps.markerZoomFactor === 1) {\n          this.maps.tileTranslatePoint.x = 0;\n          this.maps.tileTranslatePoint.y = 0;\n        }\n      }\n    }\n  };\n  /**\n   * To check and trigger marker click event\n   */\n\n\n  Marker.prototype.markerClick = function (e) {\n    var target = e.target.id;\n\n    if (target.indexOf('_LayerIndex_') === -1 || target.indexOf('_cluster_') > 0) {\n      return;\n    }\n\n    var options = this.getMarker(target);\n\n    if (isNullOrUndefined(options)) {\n      return;\n    }\n\n    var eventArgs = {\n      cancel: false,\n      name: markerClick,\n      data: options.data,\n      maps: this.maps,\n      marker: options.marker,\n      target: target,\n      x: e.clientX,\n      y: e.clientY,\n      latitude: options.data[\"latitude\"] || options.data[\"Latitude\"],\n      longitude: options.data[\"longitude\"] || options.data[\"Longitude\"],\n      value: options.data[\"name\"]\n    };\n\n    if (this.maps.isBlazor) {\n      var maps = eventArgs.maps,\n          marker_2 = eventArgs.marker,\n          blazorEventArgs = __rest(eventArgs, [\"maps\", \"marker\"]);\n\n      eventArgs = blazorEventArgs;\n    }\n\n    this.maps.trigger(markerClick, eventArgs);\n  };\n  /**\n   * To check and trigger Cluster click event\n   */\n\n\n  Marker.prototype.markerClusterClick = function (e) {\n    var target = e.target.id;\n\n    if (target.indexOf('_LayerIndex_') === -1 || target.indexOf('_cluster_') === -1) {\n      return;\n    }\n\n    var options = this.getMarker(target);\n\n    if (isNullOrUndefined(options)) {\n      return;\n    }\n\n    if (options.clusterCollection.length > 0 && this.maps.markerClusterExpand) {\n      if (getElement(this.maps.element.id + '_mapsTooltip') && this.maps.mapsTooltipModule.tooltipTargetID.indexOf('_MarkerIndex_') > -1) {\n        removeElement(this.maps.element.id + '_mapsTooltip');\n      }\n\n      if (this.sameMarkerData.length > 0 && !this.maps.markerClusterExpandCheck) {\n        this.maps.markerClusterExpandCheck = true;\n        mergeSeparateCluster(this.sameMarkerData, this.maps, this.markerSVGObject);\n      } else {\n        this.sameMarkerData = options.clusterCollection;\n        this.maps.markerClusterExpandCheck = false;\n        clusterSeparate(this.sameMarkerData, this.maps, this.markerSVGObject, true);\n      }\n    }\n\n    var eventArgs = {\n      cancel: false,\n      name: markerClusterClick,\n      data: options,\n      maps: this.maps,\n      target: target,\n      x: e.clientX,\n      y: e.clientY,\n      latitude: options.data[\"latitude\"] || options.data[\"Latitude\"],\n      longitude: options.data[\"longitude\"] || options.data[\"Longitude\"],\n      markerClusterCollection: options['markCollection']\n    };\n\n    if (this.maps.isBlazor) {\n      var maps = eventArgs.maps,\n          latitude = eventArgs.latitude,\n          longitude = eventArgs.longitude,\n          blazorEventArgs = __rest(eventArgs, [\"maps\", \"latitude\", \"longitude\"]);\n\n      eventArgs = blazorEventArgs;\n    }\n\n    this.maps.trigger(markerClusterClick, eventArgs);\n  };\n  /**\n   * To get marker from target id\n   */\n\n\n  Marker.prototype.getMarker = function (target) {\n    var id = target.split('_LayerIndex_');\n    var index = parseInt(id[1].split('_')[0], 10);\n    var layer = this.maps.layers[index];\n    var data;\n    var markCollection = [];\n    var clusterCollection = [];\n    var marker;\n    this.maps.markerClusterExpand = layer.markerClusterSettings.allowClusterExpand;\n\n    if (target.indexOf('_MarkerIndex_') > -1) {\n      var markerIndex = parseInt(id[1].split('_MarkerIndex_')[1].split('_')[0], 10);\n      var dataIndex = parseInt(id[1].split('_dataIndex_')[1].split('_')[0], 10);\n      marker = layer.markerSettings[markerIndex];\n\n      if (!isNaN(markerIndex)) {\n        data = marker.dataSource[dataIndex];\n        var collection_1 = [];\n\n        if (!marker.template && target.indexOf('_cluster_') > -1 && this.maps.layers[index].markerClusterSettings.allowClusterExpand) {\n          Array.prototype.forEach.call(marker.dataSource, function (location, index) {\n            if (location['latitude'] === data['latitude'] && location['longitude'] === data['longitude']) {\n              collection_1.push({\n                data: data,\n                index: index\n              });\n            }\n          });\n        }\n\n        if (target.indexOf('_cluster_') > -1) {\n          var isClusterSame = false;\n          var clusterElement = document.getElementById(target.indexOf('_datalabel_') > -1 ? target.split('_datalabel_')[0] : target);\n          var indexes = clusterElement.innerHTML.split(',').map(Number);\n          collection_1 = [];\n\n          for (var _i = 0, indexes_1 = indexes; _i < indexes_1.length; _i++) {\n            var i = indexes_1[_i];\n            collection_1.push({\n              data: marker.dataSource[i],\n              index: i\n            });\n\n            if (this.maps.isBlazor) {\n              marker.dataSource[i][\"text\"] = \"\";\n            }\n\n            markCollection.push(marker.dataSource[i]);\n          }\n\n          isClusterSame = false;\n          clusterCollection.push({\n            data: collection_1,\n            layerIndex: index,\n            markerIndex: markerIndex,\n            dataIndex: dataIndex,\n            targetClusterIndex: +(target.split('_cluster_')[1].indexOf('_datalabel_') > -1 ? target.split('_cluster_')[1].split('_datalabel_')[0] : target.split('_cluster_')[1]),\n            isClusterSame: isClusterSame\n          });\n        }\n\n        return {\n          marker: marker,\n          data: data,\n          clusterCollection: clusterCollection,\n          markCollection: markCollection\n        };\n      }\n    }\n\n    return null;\n  };\n  /**\n   * To check and trigger marker move event\n   */\n\n\n  Marker.prototype.markerMove = function (e) {\n    var targetId = e.target.id;\n\n    if (targetId.indexOf('_LayerIndex_') === -1 || targetId.indexOf('_cluster_') > 0) {\n      return;\n    }\n\n    var options = this.getMarker(targetId);\n\n    if (isNullOrUndefined(options)) {\n      return;\n    }\n\n    var eventArgs = {\n      cancel: false,\n      name: markerMouseMove,\n      data: options.data,\n      maps: this.maps,\n      target: targetId,\n      x: e.clientX,\n      y: e.clientY\n    };\n\n    if (this.maps.isBlazor) {\n      var maps = eventArgs.maps,\n          blazorEventArgs = __rest(eventArgs, [\"maps\"]);\n\n      eventArgs = blazorEventArgs;\n    }\n\n    this.maps.trigger(markerMouseMove, eventArgs);\n  };\n  /**\n   * To check and trigger cluster move event\n   */\n\n\n  Marker.prototype.markerClusterMouseMove = function (e) {\n    var targetId = e.target.id;\n\n    if (targetId.indexOf('_LayerIndex_') === -1 || targetId.indexOf('_cluster_') === -1) {\n      return;\n    }\n\n    var options = this.getMarker(targetId);\n\n    if (this.maps.markerClusterExpand) {\n      e.target.setAttribute('style', 'cursor: pointer');\n    }\n\n    if (isNullOrUndefined(options)) {\n      return;\n    }\n\n    var eventArgs = {\n      cancel: false,\n      name: markerClusterMouseMove,\n      data: options.data,\n      maps: this.maps,\n      target: targetId,\n      x: e.clientX,\n      y: e.clientY\n    };\n\n    if (this.maps.isBlazor) {\n      var maps = eventArgs.maps,\n          blazorEventArgs = __rest(eventArgs, [\"maps\"]);\n\n      eventArgs = blazorEventArgs;\n    }\n\n    this.maps.trigger(markerClusterMouseMove, eventArgs);\n  };\n  /**\n   * Get module name.\n   */\n\n\n  Marker.prototype.getModuleName = function () {\n    return 'Marker';\n  };\n  /**\n   * To destroy the layers.\n   * @return {void}\n   * @private\n   */\n\n\n  Marker.prototype.destroy = function (maps) {\n    /**\n     * Destroy method performed here\n     */\n  };\n\n  return Marker;\n}();\n\nexport { Marker };","map":{"version":3,"sources":["/Users/kristalduran/node_modules/@syncfusion/ej2-maps/src/maps/layers/marker.js"],"names":["__rest","s","e","t","p","Object","prototype","hasOwnProperty","call","indexOf","getOwnPropertySymbols","i","length","markerRendering","convertTileLatLongToPoint","MapLocation","markerClick","markerMouseMove","markerClusterClick","markerClusterMouseMove","isNullOrUndefined","createElement","getTranslate","convertGeoToPoint","clusterTemplate","marker","markerTemplate","getZoomTranslate","getElementByID","mergeSeparateCluster","clusterSeparate","removeElement","getElement","markerColorChoose","markerShapeChoose","calculateZoomLevel","compareZoomFactor","getValueFromObject","Marker","maps","trackElements","sameMarkerData","markerRender","layerElement","layerIndex","factor","type","_this","templateFn","markerCount","nullCount","markerTemplateCount","translateType","currentLayer","layersCollection","markerSVGObject","renderer","createGroup","id","element","class","style","markerTemplateEle","className","styles","mapAreaRect","y","x","height","width","markerSettings","map","markerIndex","markerData","dataSource","Array","forEach","data","dataIndex","markerNullCount","eventArgs","cancel","name","fill","imageUrl","shape","template","border","colorValuePath","shapeValuePath","imageUrlValuePath","isBlazor","marker_1","blazorEventArgs","longitudeValuePath","latitudeValuePath","trigger","MarkerArgs","lng","Number","parseFloat","lat","data1","text","j","keys","toLowerCase","offset","visible","markerID","location_1","isTileMap","tileTranslatePoint","animate","animationDuration","zoomModule","translate","tileZoomLevel","zoomSettings","zoomFactor","scale","transPoint","translatePoint","isNaN","markerDataLength","childElementCount","appendChild","markerClusterSettings","allowClustering","svgObject","calculateIndividualLayerMarkerZoomLevel","mapWidth","mapHeight","maxZoomFact","latZoom","lngZoom","result","scaleFactor","Math","abs","baseMapBounds","latitude","max","min","longitude","floor","log","calculateZoomCenterPositionAndFactor","shouldZoomInitially","markerModule","minLong_1","maxLat_1","minLat_1","maxLong_1","zoomLevel","centerLat","centerLong","markerZoomedState","markerZoomFactor","defaultState","isMarker","markerSetting","markerCenterLatitude","markerCenterLongitude","markerZoomCenterPoint","markerFactor","baseMapRectBounds","mapScaleValue","shouldZoomCurrentFactor","enablePersistence","target","options","getMarker","clientX","clientY","value","marker_2","clusterCollection","markerClusterExpand","mapsTooltipModule","tooltipTargetID","markerClusterExpandCheck","markerClusterCollection","split","index","parseInt","layer","layers","markCollection","allowClusterExpand","collection_1","location","push","isClusterSame","clusterElement","document","getElementById","indexes","innerHTML","_i","indexes_1","targetClusterIndex","markerMove","targetId","setAttribute","getModuleName","destroy"],"mappings":"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","sourcesContent":["var __rest = (this && this.__rest) || function (s, e) {\n    var t = {};\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n        t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)\n            t[p[i]] = s[p[i]];\n    return t;\n};\nimport { markerRendering, convertTileLatLongToPoint, MapLocation } from '../index';\nimport { markerClick, markerMouseMove, markerClusterClick, markerClusterMouseMove } from '../index';\nimport { isNullOrUndefined, createElement } from '@syncfusion/ej2-base';\nimport { getTranslate, convertGeoToPoint, clusterTemplate, marker, markerTemplate, getZoomTranslate } from '../utils/helper';\nimport { getElementByID, mergeSeparateCluster, clusterSeparate, removeElement, getElement, markerColorChoose, markerShapeChoose, calculateZoomLevel, compareZoomFactor, getValueFromObject } from '../utils/helper';\n/**\n * Marker class\n */\nvar Marker = /** @class */ (function () {\n    function Marker(maps) {\n        this.maps = maps;\n        this.trackElements = [];\n        this.sameMarkerData = [];\n    }\n    /* tslint:disable:no-string-literal */\n    Marker.prototype.markerRender = function (layerElement, layerIndex, factor, type) {\n        var _this = this;\n        var templateFn;\n        var markerCount = 0;\n        var nullCount = 0;\n        var markerTemplateCount = 0;\n        this.maps.translateType = 'marker';\n        var currentLayer = this.maps.layersCollection[layerIndex];\n        this.markerSVGObject = this.maps.renderer.createGroup({\n            id: this.maps.element.id + '_Markers_Group',\n            class: 'GroupElement',\n            style: 'pointer-events: auto;'\n        });\n        var markerTemplateEle = createElement('div', {\n            id: this.maps.element.id + '_LayerIndex_' + layerIndex + '_Markers_Template_Group',\n            className: this.maps.element.id + '_template',\n            styles: 'overflow: hidden; position: absolute;pointer-events: none;' +\n                'top:' + this.maps.mapAreaRect.y + 'px;' +\n                'left:' + this.maps.mapAreaRect.x + 'px;' +\n                'height:' + this.maps.mapAreaRect.height + 'px;' +\n                'width:' + this.maps.mapAreaRect.width + 'px;'\n        });\n        //tslint:disable\n        currentLayer.markerSettings.map(function (markerSettings, markerIndex) {\n            var markerData = markerSettings.dataSource;\n            Array.prototype.forEach.call(markerData, function (data, dataIndex) {\n                _this.maps.markerNullCount = markerIndex > 0 && dataIndex === 0 ? 0 : _this.maps.markerNullCount;\n                var eventArgs = {\n                    cancel: false, name: markerRendering, fill: markerSettings.fill, height: markerSettings.height,\n                    width: markerSettings.width, imageUrl: markerSettings.imageUrl, shape: markerSettings.shape,\n                    template: markerSettings.template, data: data, maps: _this.maps, marker: markerSettings,\n                    border: markerSettings.border, colorValuePath: markerSettings.colorValuePath,\n                    shapeValuePath: markerSettings.shapeValuePath, imageUrlValuePath: markerSettings.imageUrlValuePath\n                };\n                eventArgs = markerColorChoose(eventArgs, data);\n                eventArgs = markerShapeChoose(eventArgs, data);\n                if (_this.maps.isBlazor) {\n                    var maps = eventArgs.maps, marker_1 = eventArgs.marker, blazorEventArgs = __rest(eventArgs, [\"maps\", \"marker\"]);\n                    eventArgs = blazorEventArgs;\n                    markerSettings.longitudeValuePath = !isNullOrUndefined(markerSettings.longitudeValuePath) ?\n                        markerSettings.longitudeValuePath : !isNullOrUndefined(data['Longitude']) ? 'Longitude' :\n                        !isNullOrUndefined(data['longitude']) ? 'longitude' : null;\n                    markerSettings.latitudeValuePath = !isNullOrUndefined(markerSettings.latitudeValuePath) ?\n                        markerSettings.latitudeValuePath : !isNullOrUndefined(data['Latitude']) ? 'Latitude' :\n                        !isNullOrUndefined(data['latitude']) ? 'latitude' : null;\n                }\n                _this.maps.trigger('markerRendering', eventArgs, function (MarkerArgs) {\n                    if (markerSettings.colorValuePath !== eventArgs.colorValuePath) {\n                        eventArgs = markerColorChoose(eventArgs, data);\n                    }\n                    if (markerSettings.shapeValuePath !== eventArgs.shapeValuePath) {\n                        eventArgs = markerShapeChoose(eventArgs, data);\n                    }\n                    var lng = (!isNullOrUndefined(markerSettings.longitudeValuePath)) ?\n                        Number(getValueFromObject(data, markerSettings.longitudeValuePath)) : !isNullOrUndefined(data['longitude']) ?\n                        parseFloat(data['longitude']) : !isNullOrUndefined(data['Longitude']) ? parseFloat(data['Longitude']) : 0;\n                    var lat = (!isNullOrUndefined(markerSettings.latitudeValuePath)) ?\n                        Number(getValueFromObject(data, markerSettings.latitudeValuePath)) : !isNullOrUndefined(data['latitude']) ?\n                        parseFloat(data['latitude']) : !isNullOrUndefined(data['Latitude']) ? parseFloat(data['Latitude']) : 0;\n                    if (_this.maps.isBlazor) {\n                        var data1 = {};\n                        var text = [];\n                        var j = 0;\n                        for (var i = 0; i < Object.keys(data).length; i++) {\n                            if (Object.keys(data)[i].toLowerCase() !== 'latitude' && Object.keys(data)[i].toLowerCase() !== 'longitude'\n                                && Object.keys(data)[i].toLowerCase() !== 'name' && Object.keys(data)[i].toLowerCase() !== 'blazortemplateid'\n                                && Object.keys(data)[i].toLowerCase() !== 'text') {\n                                text[j] = data[Object.keys(data)[i].toLowerCase()];\n                                data1['text'] = text;\n                                j++;\n                            }\n                        }\n                        data['text'] = data1['text'];\n                    }\n                    var offset = markerSettings.offset;\n                    if (!eventArgs.cancel && markerSettings.visible && !isNullOrUndefined(lng) && !isNullOrUndefined(lat)) {\n                        var markerID = _this.maps.element.id + '_LayerIndex_' + layerIndex + '_MarkerIndex_'\n                            + markerIndex + '_dataIndex_' + dataIndex;\n                        var location_1 = (_this.maps.isTileMap) ? convertTileLatLongToPoint(new MapLocation(lng, lat), factor, _this.maps.tileTranslatePoint, true) : convertGeoToPoint(lat, lng, factor, currentLayer, _this.maps);\n                        var animate = currentLayer.animationDuration !== 0 || isNullOrUndefined(_this.maps.zoomModule);\n                        var translate = (_this.maps.isTileMap) ? (currentLayer.type === \"SubLayer\" && isNullOrUndefined(_this.maps.zoomModule)) ? location_1 = convertTileLatLongToPoint(new MapLocation(lng, lat), _this.maps.tileZoomLevel, _this.maps.tileTranslatePoint, true) : new Object() :\n                            !isNullOrUndefined(_this.maps.zoomModule) && _this.maps.zoomSettings.zoomFactor > 1 ?\n                                getZoomTranslate(_this.maps, currentLayer, animate) :\n                                getTranslate(_this.maps, currentLayer, animate);\n                        var scale = type === 'AddMarker' ? _this.maps.scale : translate['scale'];\n                        var transPoint = type === 'AddMarker' ? _this.maps.translatePoint : translate['location'];\n                        if (eventArgs.template && (!isNaN(location_1.x) && !isNaN(location_1.y))) {\n                            markerTemplateCount++;\n                            markerTemplate(eventArgs, templateFn, markerID, data, markerIndex, markerTemplateEle, location_1, scale, offset, _this.maps);\n                        }\n                        else if (!eventArgs.template && (!isNaN(location_1.x) && !isNaN(location_1.y))) {\n                            markerCount++;\n                            marker(eventArgs, markerSettings, markerData, dataIndex, location_1, transPoint, markerID, offset, scale, _this.maps, _this.markerSVGObject);\n                        }\n                    }\n                    nullCount += (!isNaN(lat) && !isNaN(lng)) ? 0 : 1;\n                    markerTemplateCount += (eventArgs.cancel) ? 1 : 0;\n                    markerCount += (eventArgs.cancel) ? 1 : 0;\n                    _this.maps.markerNullCount = (isNullOrUndefined(lng) || isNullOrUndefined(lat)) ? _this.maps.markerNullCount + 1 : _this.maps.markerNullCount;\n                    var markerDataLength = markerData.length - _this.maps.markerNullCount;\n                    if (_this.markerSVGObject.childElementCount === (markerDataLength - markerTemplateCount - nullCount) && (type !== 'Template')) {\n                        layerElement.appendChild(_this.markerSVGObject);\n                        if (currentLayer.markerClusterSettings.allowClustering) {\n                            _this.maps.svgObject.appendChild(_this.markerSVGObject);\n                            _this.maps.element.appendChild(_this.maps.svgObject);\n                            clusterTemplate(currentLayer, _this.markerSVGObject, _this.maps, layerIndex, _this.markerSVGObject, layerElement, true, false);\n                        }\n                    }\n                    if (markerTemplateEle.childElementCount === (markerData.length - markerCount - nullCount) && getElementByID(_this.maps.element.id + '_Secondary_Element')) {\n                        getElementByID(_this.maps.element.id + '_Secondary_Element').appendChild(markerTemplateEle);\n                        if (currentLayer.markerClusterSettings.allowClustering) {\n                            clusterTemplate(currentLayer, markerTemplateEle, _this.maps, layerIndex, _this.markerSVGObject, layerElement, false, false);\n                        }\n                    }\n                });\n            });\n        });\n    };\n    /**\n     * To find zoom level for individual layers like India, USA.\n     */\n    Marker.prototype.calculateIndividualLayerMarkerZoomLevel = function (mapWidth, mapHeight, maxZoomFact) {\n        var latZoom;\n        var lngZoom;\n        var result;\n        var scaleFactor;\n        var height = Math.abs(this.maps.baseMapBounds.latitude.max - this.maps.baseMapBounds.latitude.min);\n        var width = Math.abs(this.maps.baseMapBounds.longitude.max - this.maps.baseMapBounds.longitude.min);\n        latZoom = Math.floor(Math.log(mapHeight / height));\n        latZoom = (latZoom > maxZoomFact) ? maxZoomFact : latZoom;\n        lngZoom = Math.floor(Math.log(mapWidth / width));\n        lngZoom = (lngZoom > maxZoomFact) ? maxZoomFact : lngZoom;\n        result = Math.min(latZoom, lngZoom);\n        scaleFactor = Math.min(result, maxZoomFact - 1);\n        if (!this.maps.isTileMap) {\n            compareZoomFactor(scaleFactor, this.maps);\n        }\n        return scaleFactor;\n    };\n    /**\n     * To calculate center position and factor value dynamically\n     */\n    Marker.prototype.calculateZoomCenterPositionAndFactor = function (layersCollection) {\n        if (this.maps.zoomSettings.shouldZoomInitially && this.maps.markerModule) {\n            var minLong_1;\n            var maxLat_1;\n            var minLat_1;\n            var maxLong_1;\n            var latZoom = void 0;\n            var lngZoom = void 0;\n            var result = void 0;\n            var zoomLevel = void 0;\n            var centerLat = void 0;\n            var centerLong = void 0;\n            var maxZoomFact = 10;\n            var mapWidth = this.maps.mapAreaRect.width;\n            var mapHeight = this.maps.mapAreaRect.height;\n            var scaleFactor = void 0;\n            this.maps.markerZoomedState = this.maps.markerZoomedState ? this.maps.markerZoomedState : isNullOrUndefined(this.maps.markerZoomFactor) ?\n                !this.maps.markerZoomedState : this.maps.markerZoomFactor > 1 ? this.maps.markerZoomedState : !this.maps.markerZoomedState;\n            this.maps.defaultState = this.maps.markerZoomedState ? !this.maps.markerZoomedState : this.maps.defaultState;\n            Array.prototype.forEach.call(layersCollection, function (currentLayer, layerIndex) {\n                var isMarker = currentLayer.markerSettings.length !== 0;\n                if (isMarker) {\n                    Array.prototype.forEach.call(currentLayer.markerSettings, function (markerSetting, markerIndex) {\n                        var markerData = markerSetting.dataSource;\n                        Array.prototype.forEach.call(markerData, function (data, dataIndex) {\n                            var latitude = !isNullOrUndefined(data['latitude']) ? parseFloat(data['latitude']) :\n                                !isNullOrUndefined(data['Latitude']) ? parseFloat(data['Latitude']) : null;\n                            var longitude = !isNullOrUndefined(data['longitude']) ? parseFloat(data['longitude']) :\n                                !isNullOrUndefined(data['Longitude']) ? parseFloat(data['Longitude']) : null;\n                            minLong_1 = isNullOrUndefined(minLong_1) && dataIndex === 0 ?\n                                longitude : minLong_1;\n                            maxLat_1 = isNullOrUndefined(maxLat_1) && dataIndex === 0 ?\n                                latitude : maxLat_1;\n                            minLat_1 = isNullOrUndefined(minLat_1) && dataIndex === 0 ?\n                                latitude : minLat_1;\n                            maxLong_1 = isNullOrUndefined(maxLong_1) && dataIndex === 0 ?\n                                longitude : maxLong_1;\n                            if (minLong_1 > longitude) {\n                                minLong_1 = longitude;\n                            }\n                            if (minLat_1 > latitude) {\n                                minLat_1 = latitude;\n                            }\n                            if (maxLong_1 < longitude) {\n                                maxLong_1 = longitude;\n                            }\n                            if (maxLat_1 < latitude) {\n                                maxLat_1 = latitude;\n                            }\n                        });\n                    });\n                }\n            });\n            if (!isNullOrUndefined(minLat_1) && !isNullOrUndefined(minLong_1) &&\n                !isNullOrUndefined(maxLong_1) && !isNullOrUndefined(maxLat_1)) {\n                // To find the center position\n                centerLat = (minLat_1 + maxLat_1) / 2;\n                centerLong = (minLong_1 + maxLong_1) / 2;\n                this.maps.markerCenterLatitude = centerLat;\n                this.maps.markerCenterLongitude = centerLong;\n                if (isNullOrUndefined(this.maps.markerZoomCenterPoint) || this.maps.markerZoomedState) {\n                    this.maps.markerZoomCenterPoint = {\n                        latitude: centerLat,\n                        longitude: centerLong\n                    };\n                }\n                var markerFactor = void 0;\n                if (this.maps.isTileMap || this.maps.baseMapRectBounds['min']['x'] === 0) {\n                    zoomLevel = calculateZoomLevel(minLat_1, maxLat_1, minLong_1, maxLong_1, mapWidth, mapHeight, this.maps);\n                    if (this.maps.isTileMap) {\n                        markerFactor = isNullOrUndefined(this.maps.markerZoomFactor) ?\n                            zoomLevel : isNullOrUndefined(this.maps.mapScaleValue) ?\n                            zoomLevel : this.maps.mapScaleValue > 1 && this.maps.markerZoomFactor !== 1 ?\n                            this.maps.mapScaleValue : zoomLevel;\n                    }\n                    else {\n                        markerFactor = isNullOrUndefined(this.maps.mapScaleValue) ? zoomLevel :\n                            (Math.floor(this.maps.scale) !== 1 &&\n                                this.maps.mapScaleValue !== zoomLevel)\n                                &&\n                                    (isNullOrUndefined(this.maps.shouldZoomCurrentFactor))\n                                ? this.maps.mapScaleValue : zoomLevel;\n                        if (((markerFactor === this.maps.mapScaleValue &&\n                            (this.maps.markerZoomFactor === 1 || this.maps.mapScaleValue === 1))\n                            && (!this.maps.enablePersistence))) {\n                            markerFactor = zoomLevel;\n                        }\n                    }\n                }\n                else {\n                    zoomLevel = this.calculateIndividualLayerMarkerZoomLevel(mapWidth, mapHeight, maxZoomFact);\n                    markerFactor = isNullOrUndefined(this.maps.mapScaleValue) ? zoomLevel :\n                        (this.maps.mapScaleValue !== zoomLevel)\n                            ? this.maps.mapScaleValue : zoomLevel;\n                }\n                this.maps.markerZoomFactor = markerFactor;\n            }\n        }\n        else {\n            this.maps.markerZoomedState = false;\n            if (this.maps.markerZoomFactor > 1) {\n                this.maps.markerCenterLatitude = null;\n                this.maps.markerCenterLongitude = null;\n                this.maps.markerZoomFactor = 1;\n                if (!this.maps.enablePersistence) {\n                    this.maps.mapScaleValue = 1;\n                }\n            }\n            if (this.maps.isTileMap && !this.maps.enablePersistence\n                && this.maps.mapScaleValue <= 1) {\n                this.maps.tileZoomLevel = this.maps.mapScaleValue === 0 ? 1 : this.maps.mapScaleValue;\n                if (this.maps.mapScaleValue === 1 && this.maps.markerZoomFactor === 1) {\n                    this.maps.tileTranslatePoint.x = 0;\n                    this.maps.tileTranslatePoint.y = 0;\n                }\n            }\n        }\n    };\n    /**\n     * To check and trigger marker click event\n     */\n    Marker.prototype.markerClick = function (e) {\n        var target = e.target.id;\n        if (target.indexOf('_LayerIndex_') === -1 || target.indexOf('_cluster_') > 0) {\n            return;\n        }\n        var options = this.getMarker(target);\n        if (isNullOrUndefined(options)) {\n            return;\n        }\n        var eventArgs = {\n            cancel: false, name: markerClick, data: options.data, maps: this.maps,\n            marker: options.marker, target: target, x: e.clientX, y: e.clientY,\n            latitude: options.data[\"latitude\"] || options.data[\"Latitude\"],\n            longitude: options.data[\"longitude\"] || options.data[\"Longitude\"],\n            value: options.data[\"name\"]\n        };\n        if (this.maps.isBlazor) {\n            var maps = eventArgs.maps, marker_2 = eventArgs.marker, blazorEventArgs = __rest(eventArgs, [\"maps\", \"marker\"]);\n            eventArgs = blazorEventArgs;\n        }\n        this.maps.trigger(markerClick, eventArgs);\n    };\n    /**\n     * To check and trigger Cluster click event\n     */\n    Marker.prototype.markerClusterClick = function (e) {\n        var target = e.target.id;\n        if (target.indexOf('_LayerIndex_') === -1 || target.indexOf('_cluster_') === -1) {\n            return;\n        }\n        var options = this.getMarker(target);\n        if (isNullOrUndefined(options)) {\n            return;\n        }\n        if ((options.clusterCollection.length > 0 && this.maps.markerClusterExpand)) {\n            if (getElement(this.maps.element.id + '_mapsTooltip') &&\n                this.maps.mapsTooltipModule.tooltipTargetID.indexOf('_MarkerIndex_') > -1) {\n                removeElement(this.maps.element.id + '_mapsTooltip');\n            }\n            if (this.sameMarkerData.length > 0 && !this.maps.markerClusterExpandCheck) {\n                this.maps.markerClusterExpandCheck = true;\n                mergeSeparateCluster(this.sameMarkerData, this.maps, this.markerSVGObject);\n            }\n            else {\n                this.sameMarkerData = options.clusterCollection;\n                this.maps.markerClusterExpandCheck = false;\n                clusterSeparate(this.sameMarkerData, this.maps, this.markerSVGObject, true);\n            }\n        }\n        var eventArgs = {\n            cancel: false, name: markerClusterClick, data: options, maps: this.maps,\n            target: target, x: e.clientX, y: e.clientY,\n            latitude: options.data[\"latitude\"] || options.data[\"Latitude\"], longitude: options.data[\"longitude\"] || options.data[\"Longitude\"],\n            markerClusterCollection: options['markCollection']\n        };\n        if (this.maps.isBlazor) {\n            var maps = eventArgs.maps, latitude = eventArgs.latitude, longitude = eventArgs.longitude, blazorEventArgs = __rest(eventArgs, [\"maps\", \"latitude\", \"longitude\"]);\n            eventArgs = blazorEventArgs;\n        }\n        this.maps.trigger(markerClusterClick, eventArgs);\n    };\n    /**\n     * To get marker from target id\n     */\n    Marker.prototype.getMarker = function (target) {\n        var id = target.split('_LayerIndex_');\n        var index = parseInt(id[1].split('_')[0], 10);\n        var layer = this.maps.layers[index];\n        var data;\n        var markCollection = [];\n        var clusterCollection = [];\n        var marker;\n        this.maps.markerClusterExpand = layer.markerClusterSettings.allowClusterExpand;\n        if (target.indexOf('_MarkerIndex_') > -1) {\n            var markerIndex = parseInt(id[1].split('_MarkerIndex_')[1].split('_')[0], 10);\n            var dataIndex = parseInt(id[1].split('_dataIndex_')[1].split('_')[0], 10);\n            marker = layer.markerSettings[markerIndex];\n            if (!isNaN(markerIndex)) {\n                data = marker.dataSource[dataIndex];\n                var collection_1 = [];\n                if (!marker.template && (target.indexOf('_cluster_') > -1) && (this.maps.layers[index].markerClusterSettings.allowClusterExpand)) {\n                    Array.prototype.forEach.call(marker.dataSource, function (location, index) {\n                        if (location['latitude'] === data['latitude'] && location['longitude'] === data['longitude']) {\n                            collection_1.push({ data: data, index: index });\n                        }\n                    });\n                }\n                if ((target.indexOf('_cluster_') > -1)) {\n                    var isClusterSame = false;\n                    var clusterElement = document.getElementById(target.indexOf('_datalabel_') > -1 ? target.split('_datalabel_')[0] : target);\n                    var indexes = clusterElement.innerHTML.split(',').map(Number);\n                    collection_1 = [];\n                    for (var _i = 0, indexes_1 = indexes; _i < indexes_1.length; _i++) {\n                        var i = indexes_1[_i];\n                        collection_1.push({ data: marker.dataSource[i], index: i });\n                        if (this.maps.isBlazor) {\n                            marker.dataSource[i][\"text\"] = \"\";\n                        }\n                        markCollection.push(marker.dataSource[i]);\n                    }\n                    isClusterSame = false;\n                    clusterCollection.push({\n                        data: collection_1, layerIndex: index, markerIndex: markerIndex, dataIndex: dataIndex,\n                        targetClusterIndex: +(target.split('_cluster_')[1].indexOf('_datalabel_') > -1 ? target.split('_cluster_')[1].split('_datalabel_')[0] : target.split('_cluster_')[1]),\n                        isClusterSame: isClusterSame\n                    });\n                }\n                return { marker: marker, data: data, clusterCollection: clusterCollection, markCollection: markCollection };\n            }\n        }\n        return null;\n    };\n    /**\n     * To check and trigger marker move event\n     */\n    Marker.prototype.markerMove = function (e) {\n        var targetId = e.target.id;\n        if (targetId.indexOf('_LayerIndex_') === -1 || targetId.indexOf('_cluster_') > 0) {\n            return;\n        }\n        var options = this.getMarker(targetId);\n        if (isNullOrUndefined(options)) {\n            return;\n        }\n        var eventArgs = {\n            cancel: false, name: markerMouseMove, data: options.data,\n            maps: this.maps, target: targetId, x: e.clientX, y: e.clientY\n        };\n        if (this.maps.isBlazor) {\n            var maps = eventArgs.maps, blazorEventArgs = __rest(eventArgs, [\"maps\"]);\n            eventArgs = blazorEventArgs;\n        }\n        this.maps.trigger(markerMouseMove, eventArgs);\n    };\n    /**\n     * To check and trigger cluster move event\n     */\n    Marker.prototype.markerClusterMouseMove = function (e) {\n        var targetId = e.target.id;\n        if (targetId.indexOf('_LayerIndex_') === -1 || targetId.indexOf('_cluster_') === -1) {\n            return;\n        }\n        var options = this.getMarker(targetId);\n        if (this.maps.markerClusterExpand) {\n            e.target.setAttribute('style', 'cursor: pointer');\n        }\n        if (isNullOrUndefined(options)) {\n            return;\n        }\n        var eventArgs = {\n            cancel: false, name: markerClusterMouseMove, data: options.data, maps: this.maps,\n            target: targetId, x: e.clientX, y: e.clientY\n        };\n        if (this.maps.isBlazor) {\n            var maps = eventArgs.maps, blazorEventArgs = __rest(eventArgs, [\"maps\"]);\n            eventArgs = blazorEventArgs;\n        }\n        this.maps.trigger(markerClusterMouseMove, eventArgs);\n    };\n    /**\n     * Get module name.\n     */\n    Marker.prototype.getModuleName = function () {\n        return 'Marker';\n    };\n    /**\n     * To destroy the layers.\n     * @return {void}\n     * @private\n     */\n    Marker.prototype.destroy = function (maps) {\n        /**\n         * Destroy method performed here\n         */\n    };\n    return Marker;\n}());\nexport { Marker };\n"]},"metadata":{},"sourceType":"module"}